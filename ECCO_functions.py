# Various functions developed for the ECCO project 
# Author: Benjamin A Laken (blaken@geo.uio.no)
#
import matplotlib.pyplot as plt
import numpy as np
import sys
import os
from matplotlib.path import Path
from matplotlib import cm
import matplotlib.patches as patches
from matplotlib import path
from matplotlib.transforms import Bbox
import json
from math import pi, cos, radians
#-------------------------------------------------------------------------------------------------------

# Purpose - Take gridded data and, using the assumption of a spherical earth, re-project it to
#			a spherical coordinate system.
# Input   - The Matplolib.Path.Path object vertexes
# Output  - x,y coordinates projected onto a sphere
# Notes   - Solution from stackoverflow.com/questions/4681737/how-to-calculate-the-area-of-a-polygon-on-the-earths-surface-using-python
#           By multiplying the latitude by the length of one degree of latitude, and the longitude by the length of
#           a degree of latitude and the cosine of the latitude. Then, calculate the area of an arbitrary polygon in a plane.
#
def EqArea(verts):
    earth_radius = 6367.4447        # Earth avg. radius (km) from Wolfram Alpha
    lat_dist = pi * earth_radius / 180.0  
    eqout =[]
    for n,i in enumerate(verts):
        longitude = i[0] 
        latitude = i[1]
        x = longitude * lat_dist * cos(radians(latitude))
        y = latitude * lat_dist
        eqout.append([x,y])
    return eqout

# Purpose - Simulate some raster data and lon/lat subscripts to test the rest of the software without
#           Needing to access real data.
# Input   - lon_dim(integer), lat_dim(integer)
# Output  - simdat(2D array of dimensions specified) with random values from 0.0 to 1.0
#			lon_atts, lat_atts (subscripts for the array)
# Notes   - The simulated data is also offset by a specified decimal degree value called offset.
#
def Gen_Test_Dat(lon_dim,lat_dim,lout):
    simdat = np.random.rand(lon_dim,lat_dim)  
    lat_atts = [] ; lon_atts =[]
    offset = 0.05   # Offset to expand the data around the lake area (in decimal degrees)
    lonextr,latextr = Get_LatLonLim(lout.vertices)       # Get the extremes of the verticies
    lon_atts = np.linspace((lonextr[1]-offset),(lonextr[0]+offset),lon_dim)
    lat_atts = np.linspace((latextr[1]-offset),(latextr[0]+offset),lat_dim)
    return simdat,lon_atts,lat_atts

# Purpose - Find the bounding (i.e. max/min) lat/lons of a given lake.
# Input   - Path.verticies of Lake
# Output  - x[max,min],y[max,min]
#
def Get_LatLonLim(xypath):
    xset = []
    yset = []
    for i in xypath:
        yset.append(i[1])
        xset.append(i[0])
    return [max(xset),min(xset)],[max(yset),min(yset)]

# Purpose - Provides a 2D array matching the input array, which has the weights of pixels
#			to calculate the lake mean. 
# Input   - lake_in(A Lake Path Object)
#			A 2D array of values: either real data, or fake data generated by Gen_Test_Dat() 
#			list of Longitude subscripts, list of latitude subscripts (also real or fake from function)
# Output  - pix_weights(A 2D array matching the input data of the fractional area of lake per pixel)
# Notes   - For each grid cell of the provided 2D data the individual bounding box of each pixel is calculated
# 			as a bounding box object (Matplotlib.Transform.Bbox). 
# 			Using the intersects_bbox() function, a logic test determines if any vectors of the
#			Lake's path are within the bounding box. If the condition is false (no lake within pixel),
#			the value of the mask is set to 0.0. If the condition is true (lake within pixel), the
#           fractional area of the lake polygon within the polygon within the pixel is calculated. 
#			This requires the area of the lake polygon within the pixel (in km^2) is calculated, and
#			divided by the area of the total lake (also in km^2). 
#			The areas are calculated by the functions EqArea() and PolyArea2D() within this file.
#
def Pixel_Weights(lake_in, datin,lon_atts,lat_atts):
    lout = lake_in
    pix_weights = np.zeros(np.shape(datin))
    cnt = 0
    latstep = (float(lat_atts[-1]) - float(lat_atts[0])) / float(len(lat_atts))
    lonstep = (float(lon_atts[-1]) - float(lon_atts[0])) / float(len(lon_atts))
    xvar = lon_atts[0] ; yvar= lat_atts[0]       # Initialize the looping indexes to first positions
    for x in xrange(len(lon_atts)):
        if(x == 0):  
            x_ll = lon_atts[0]                   # ..then set the lower left corner to be the first lon val.
            x_ur = lonstep + x_ll                # and the upper right, to be the x_ll + increment
        if(x > 0):                               # If it is already in the loop, use the older x_ll, and x_ur
            x_ll = x_ur                          # to continue calculating the bounding box area. 
            x_ur = x_ll + lonstep    
        for y in xrange(len(lat_atts)):
            if(y == 0):
                y_ll = lat_atts[0]
                y_ur = latstep + y_ll
            if(y > 0):
                y_ll = y_ur
                y_ur = y_ll + latstep       
            lims =np.array([[x_ll,y_ll],[x_ur,y_ur]])  # Construct a 2D np.array for the BB object
            tmpbb = Bbox(lims)
            test = lout.intersects_bbox(tmpbb)
            if (test == 1):                         # If Lake within the Bbox test will be 1 (no lake, test = 0)
                cnt = cnt + 1                     # Counter is just for testing.
                pix_weights[y,x] = 0.0            # For each pixel where Lake exists, calculate and write the fractional area (%).
                sub_lout =[] ; area_sub = []
                sub_lout = lout.clip_to_bbox(tmpbb,inside ='True')
                area_sub = Poly_Area2D(EqArea(sub_lout.vertices))
                lkarea = Poly_Area2D(EqArea(lout.vertices))
                #pix_weights[y,x]=((area_sub/lkarea)*100.)   # The area: i.e. The % of lake within a given pixel
                pix_weights[y,x]=((area_sub/lkarea))         # The fractional area (0-1.0) of lake within a given pixel
    return pix_weights

# Purpose - This function implements Green's Theorem to calculate to find the
#           area of a polygon in a 2D co-ordinate system.
# Input   - A polygon, as the verticies of a Matplotlib.Path 
# Notes   - More info at http://code.activestate.com/recipes/578275-2d-polygon-area
#  			Join this function with EqArea function to find the area of a lake in km^2.
#			An example of how this is done is given below.
# Example - area = Poly_area2D(EqArea(A_Lake_Path.vertices))
#
def Poly_Area2D(poly):
    total = 0.0
    N = len(poly)
    for i in range(N):
        v1 = poly[i]
        v2 = poly[(i+1) % N]
        total += v1[0]*v2[1] - v1[1]*v2[0]
    return abs(total/2.)  

# Purpose - Plot to screen a specified lake overlaid onto weighted pixels
#			from Pixel_Weights() function.
# Input   - Lake object
#			2D array of pix_weights (output of Pixel_Weights)
# Notes   - Currently only designed to display data that is zoomed on lake.
#
def Preview_Weights(lake_in,pix_weights,lon_atts,lat_atts):
    lout = lake_in
    fig2 = plt.figure()
    ax1 = fig2.add_subplot(111)
    patch = patches.PathPatch(lout, facecolor='#06ebf6', lw=1)
    ax1.add_patch(patch)     # ADD LAKE
    ax1.set_xlim(lon_atts[0],lon_atts[-1])
    ax1.set_ylim(lat_atts[0],lat_atts[-1])
    ax1.set_ylabel('Lat. (Deg. N)')
    ax1.set_xlabel('Lon. (Deg. E)') 
    ax1.imshow(pix_weights,interpolation='none', cmap=cm.Greys, extent=[lon_atts[0],lon_atts[-1],lat_atts[0],lat_atts[-1]],origin='lower')
    plt.show()
    return

# Purpose - Create a Polygon from the Lake vectors, as a Matplotlib.Path.Path object
# Input   - Lake coordinate data as an x,y list (from the GeoJSON file).
# Output  - Path_out (A Matplotlib.Path object) 
#		    Also the X/y lower/upper corners of the lake Lon/Lats
# Requires- Matplotlib.Path import Path
# Notes   - The way the lake addressing goes is Lake[0][0][0] where the first 0 is the 
#           individual lake. Lake[0][0][:] will give you every x,y element. Lake[0][0][0][0]
#           will give the first x-element of the first lake. Lake[0][0][0][1] will give the 
#           first y-element etc.
def Pth_Create(coord):
    verts =[] ; codes=[] ; xonly =[] ; yonly =[]
    pth_ln = int(len(coord) - 1) 
    for i,n in enumerate(coord[0:pth_ln]):
        #print i,n
        verts.append(n)
        if i == 0:
            codes.append(Path.MOVETO)
        if ((i >= 1)&(i < (pth_ln - 1))):
            codes.append(Path.LINETO)  
        if i == (pth_ln - 1):
            codes.append(Path.CLOSEPOLY)
    path_out = Path(verts, codes)
    # Now find the Lat/Lon edges
    for i in xrange(len(path_out.vertices)):
        xonly.append(path_out.vertices[i][0])
        yonly.append(path_out.vertices[i][1])   
    return path_out,min(xonly),max(xonly),min(yonly),max(yonly)

# Purpose - Use Json module to read GeoJSON Lake data
# Input   - File name including path (string)
# Output  - Various arrays containing Lake data
#
def Read_Lakes(file_in):
    with open(file_in) as f:
        data = json.load(f)
    lake_id =[] ; lake_path=[] ; lake_geometry=[] ; lake_name=[]
    for feature in data['features']:
        lake_geometry.append(feature['geometry']['type'])
        lake_id.append(feature['id'])
        lake_name.append(feature['properties']['comsat.Lake'])
        lake_path.append(feature['geometry']['coordinates'])
    print 'Read data for', len(lake_id), ' lakes.'
    return lake_geometry, lake_id, lake_name,lake_path

# Purpose - Function to print to screen some basic info on a given lake (specified by
#           the integer order from which the lakes were read in).
# Input   - Integer value 
# Output  - None, only prints to screen
#
def Show_Lake_Info(ival,lake_id,lake_name,lake_path):
    print 
    print 'ID',lake_id[0],
    print ' Name',lake_name[0]
    print 'Number of x,y vectors',len(lake_path[ival][0][0][:])
    print "First x,y vector",lake_path[ival][0][0][0]
    return

# Purpose - Create a plot of the lake with Lat Lon axes (decimal degrees)
# Input   - An integer specifying the lake number of interest (the int relates
#           to the order in which the lakes were read in.
#
def Show_Lake_Plot(ln,lake_path,lake_name,lake_id):
    lout,x1,x2,y1,y2 = Pth_Create(lake_path[ln][0][0][:])
    fig = plt.figure()
    ax = fig.add_subplot(111)
    patch = patches.PathPatch(lout, facecolor='#0000ff', lw=1)  #hexcolour is a blue
    ax.add_patch(patch)
    ax.set_axis_bgcolor('#87c540')   # hexcolor is a green
    ax.set_xlim(x1-0.05,x2+0.05)
    ax.set_ylim(y1-0.05,y2+0.05)
    ax.set_ylabel('Lat. (Deg. N)')
    ax.set_xlabel('Lon. (Deg. E)')
    title_string = "Lake ID: "+ str(lake_id[ln])+',  Name: '+lake_name[ln]+"\n"
    title_string += "From "+str(len(lout.vertices[:]))+' datapoints'
    plt.title(title_string) 
    plt.show()
    return

# Purpose - Provide a mean of 2D data, weighted by the fraction of lake in each pixel
# Input   - pix_weights: output of Pixel_Weights()
# 			dat_in : a 2D slice (per day) of the data for which you want the mean
# Output  - Val_out (a float): The weighted mean value
#
def Weighted_Mean(pix_weights,dat_in):
    aind = np.where(pix_weights > 0.0)   # Identify pixels where lake values exists
    if (len(aind[0]) == 0):
        print 'Error: no area data found in mask (in function area_avg)'
    val_out = []
    val_out = sum(dat_in[aind] * pix_weights[aind])/len(aind[0])
    #print 'Check the total weight of the lake is 1: ',"%6.2f"%(sum(pix_weights[aind]))
    return val_out